<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>FotoSlide 9+1</title>
<style>
  :root{
    --bg:#0f141b; --panel:#121a23; --muted:#9fb3c9; --tile:#101722;
    --accent:#6ab0ff; --grid:rgba(230,238,247,.18);
    --gap:4px; --radius-cell:8px; --radius-board:12px;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:680px;margin:0 auto;padding:16px}
  header{display:flex;align-items:center;justify-content:space-between;gap:8px}
  h1{font-size:20px;margin:0}
  .controls-top{display:flex;gap:8px;flex-wrap:wrap}
  button,label.btn{background:var(--panel);color:#e6eef7;border:1px solid rgba(255,255,255,.12);padding:10px 12px;border-radius:10px;cursor:pointer}
  button[disabled],label.btn.disabled{opacity:.5;cursor:not-allowed}
  button:hover,label.btn:hover{border-color:rgba(255,255,255,.25)}
  input[type=file]{display:none}
  .counter{min-width:48px;text-align:center;padding:8px 12px;border:1px solid rgba(255,255,255,.12);border-radius:999px;background:rgba(255,255,255,.05);font-weight:700}

  .stage{position:relative;width:100%;max-width:460px;margin:16px auto 10px}
  .board-wrap{position:relative;width:100%;aspect-ratio:1/1}
  .board{
    position:absolute; inset:0;
    display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr);
    gap:var(--gap); padding:calc(var(--gap) - 1px);
    background:linear-gradient(180deg,#0b1118,#0e1722);
    border:1px solid rgba(255,255,255,.05); border-radius:var(--radius-board);
  }
  .cell{
    border-radius:var(--radius-cell);
    border:1px solid rgba(255,255,255,.06);
    background:var(--tile);
    background-repeat:no-repeat;
    background-size:300% 300%;
    image-rendering:crisp-edges;
    will-change:transform;
    transition:box-shadow .12s ease, background-color .12s ease;
    display:flex; align-items:center; justify-content:center;
    overflow:hidden;
    touch-action:none;
  }
  .cell.movable{ box-shadow:0 0 0 2px var(--accent) inset }

  .grid-overlay{ position:absolute; inset:calc(var(--gap) - 1px); pointer-events:none }
  .gline{ position:absolute; background:var(--grid); border-radius:1px }
  .gv1{ top:0; bottom:0; left:calc(33.333% - .5px); width:1px }
  .gv2{ top:0; bottom:0; left:calc(66.666% - .5px); width:1px }
  .gh1{ left:0; right:0; top:calc(33.333% - .5px); height:1px }
  .gh2{ left:0; right:0; top:calc(66.666% - .5px); height:1px }

  .bottom-bar{width:100%;max-width:460px;margin:var(--gap) auto 0;display:flex;align-items:center;justify-content:space-between;gap:12px}
  .controls-bottom{display:flex;gap:8px;flex-wrap:wrap}
  .dock{
    position:relative; border-radius:var(--radius-cell);
    border:1px solid rgba(255,255,255,.06);
    background:linear-gradient(180deg,#0b1118,#0e1722);
    display:flex; align-items:center; justify-content:center;
    overflow:hidden;
    width:140px; height:140px; /* se ajusta luego a celda */
  }
  .dock .cell{ width:100%; height:100%; border:none; border-radius:var(--radius-cell) }

  /* Canvas de v√≠deo tablero */
 #videoCanvas{
  position:absolute; inset:calc(var(--gap) - 1px);
  width:calc(100% - 2*(var(--gap) - 1px));
  height:calc(100% - 2*(var(--gap) - 1px));
  pointer-events:none;
  border-radius:calc(var(--radius-board) - 2px);
  z-index:2;
}
#fxCanvas{
  position:absolute; inset:calc(var(--gap) - 1px);
  width:calc(100% - 2*(var(--gap) - 1px));
  height:calc(100% - 2*(var(--gap) - 1px));
  pointer-events:none;
  border-radius:calc(var(--radius-board) - 2px);
  z-index:3; /* por encima del v√≠deo */
}
.grid-overlay{ z-index:1; } /* opcional: que quede debajo del highlight */

  /* Canvas del muelle (casilla 10) */
  #dockCanvas{
    position:absolute; inset:0;
    width:100%; height:100%;
    pointer-events:none;
    border-radius:var(--radius-cell);
  }

  .toast{
    position:absolute; left:50%; top:10px; transform:translateX(-50%);
    padding:8px 12px; border-radius:10px;
    background:rgba(0,0,0,.35); backdrop-filter:blur(6px);
    border:1px solid rgba(255,255,255,.18);
    font-weight:700; opacity:0; pointer-events:none; transition:opacity .25s ease;
  }
  .toast.show{ opacity:1 }
  .cell.movable {
  box-shadow: none !important;
}

</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>FotoSlide 9+1</h1>
    <div class="controls-top">
      <label for="fileInput" class="btn" id="loadBtn">Cargar foto / v√≠deo</label>
    </div>
    <div class="counter" id="moves">0</div>
  </header>

  <div class="stage">
    <div class="board-wrap">
      <div id="board" class="board"></div>
      <canvas id="videoCanvas"></canvas>
      <canvas id="fxCanvas"></canvas> <!-- üëà capa de highlight -->
     
      <div class="grid-overlay">
        <div class="gline gv1"></div><div class="gline gv2"></div>
        <div class="gline gh1"></div><div class="gline gh2"></div>
      </div>
      <div class="toast" id="toast">¬°Resuelto!</div>
    </div>

    <div class="bottom-bar">
      <div class="controls-bottom">
        <button id="showBtn" disabled>Mostrar</button>
        <button id="shuffleBtn" disabled>Mezclar</button>
      </div>
      <div id="dock" class="dock" title="Muelle (hueco externo)">
        <!-- nuevo canvas para el muelle -->
        <canvas id="dockCanvas"></canvas>
      </div>
    </div>
  </div>

  <input id="fileInput" type="file" accept="image/*,video/*">
</div>

<script>
  const EMPTY = -1;
  let pos = [0,1,2,3,4,5,6,7,8, EMPTY];
  let moves = 0;

  let mediaURL = null;
  let mediaType = null;   // 'image' | 'video'
  let ready = false;
  let drawingSuspended = false;

  // --- VIDEO: maestro + canvas + boomerang optimizado ---
  const vCanvas = document.getElementById('videoCanvas');
  const vctx = vCanvas.getContext('2d');

  // canvas del muelle
  const dCanvas = document.getElementById('dockCanvas');
  const dctx = dCanvas.getContext('2d');
  const fxCanvas = document.getElementById('fxCanvas');
  const fctx = fxCanvas.getContext('2d');

  // buffer de baja resoluci√≥n
  const srcCanvas = document.createElement('canvas');
  const sctx = srcCanvas.getContext('2d', { willReadFrequently: true });
  const SRC_SIZE = 640;

  // backbuffer para el tablero
  const backCanvas = document.createElement('canvas');
  const bctx = backCanvas.getContext('2d');

  let masterVideo = null;
  const BOOM_END = 3; // s
  let rafId = null;

  // layout cacheado
  let layout = null; // {dpr, cells:[...], dock:{x,y,w,h}}

  const boardEl   = document.getElementById('board');
  const dockEl    = document.getElementById('dock');
  const movesEl   = document.getElementById('moves');
  const fileInput = document.getElementById('fileInput');
  const shuffleBtn= document.getElementById('shuffleBtn');
  const showBtn   = document.getElementById('showBtn');
  const toastEl   = document.getElementById('toast');

  let showing = false;
  let savedPos = null;

  const neighbors = {
    0:[1,3], 1:[0,2,4], 2:[1,5],
    3:[0,4,6], 4:[1,3,5,7], 5:[2,4,8],
    6:[3,7], 7:[4,6,8],
    8:[5,7,9], 9:[8]
  };

  function cellBackground(el, val){
    const col = val % 3;
    const row = (val / 3) | 0;
    const px = col === 0 ? '0%' : (col === 1 ? '50%' : '100%');
    const py = row === 0 ? '0%' : (row === 1 ? '50%' : '100%');
    el.style.backgroundImage = `url('${mediaURL}')`;
    el.style.backgroundPosition = `${px} ${py}`;
    el.style.backgroundColor = '';
    el.style.outline = '';
  }

  /* ---------- Layout y tama√±os (DPR aware) ---------- */
  function sizeDockToCell(){
    const firstCell = boardEl.querySelector('.cell');
    if(!firstCell) return;
    const r = firstCell.getBoundingClientRect();
    dockEl.style.width  = r.width  + 'px';
    dockEl.style.height = r.height + 'px';
  }

  function computeLayout(){
    const dpr = window.devicePixelRatio || 1;
    const rB = boardEl.getBoundingClientRect();

    // canvas del tablero
   const newW = Math.max(1, Math.round(rB.width  * dpr));
const newH = Math.max(1, Math.round(rB.height * dpr));
if (vCanvas.width !== newW || vCanvas.height !== newH) {
  vCanvas.width = newW; vCanvas.height = newH;
}
    if (fxCanvas.width !== newW || fxCanvas.height !== newH) {
      fxCanvas.width = newW; fxCanvas.height = newH;
    }
    // celdas del tablero
    const cellEls = [...boardEl.querySelectorAll('.cell')].slice(0, 9);
    const cells = cellEls.map(el => {
      const r = el.getBoundingClientRect();
      return {
        x: Math.round((r.left - rB.left) * dpr),
        y: Math.round((r.top  - rB.top ) * dpr),
        w: Math.round(r.width  * dpr),
        h: Math.round(r.height * dpr),
      };
    });

    // muelle (posici√≥n y tama√±o en CSS px)
    const rd = dockEl.getBoundingClientRect();
    // redimensionar el canvas del muelle al DPR
    const dw = Math.max(1, Math.round(rd.width  * dpr));
    const dh = Math.max(1, Math.round(rd.height * dpr));
    if (dCanvas.width !== dw || dCanvas.height !== dh){
      dCanvas.width = dw; dCanvas.height = dh;
    }

    // guardamos layout (x,y del muelle no se usan para dCanvas)
    const dock = {
      x: Math.round((rd.left - rB.left) * dpr),
      y: Math.round((rd.top  - rB.top ) * dpr),
      w: dw,
      h: dh,
    };

    layout = { dpr, cells, dock };
  }
function roundRectPath(ctx, x,y,w,h, r){
  const rr = Math.min(r, w/2, h/2);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y,   x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x,   y+h, rr);
  ctx.arcTo(x,   y+h, x,   y,   rr);
  ctx.arcTo(x,   y,   x+w, y,   rr);
  ctx.closePath();
}
function drawHighlights(){
  if (!layout) return;
  const dpr = layout.dpr || (window.devicePixelRatio || 1);
  fctx.clearRect(0,0,fxCanvas.width,fxCanvas.height);

  const emptyPos = pos.indexOf(EMPTY);
  if (emptyPos < 0) return;

  fctx.lineWidth = Math.max(2, 2*dpr);
  fctx.strokeStyle = getComputedStyle(document.documentElement)
                      .getPropertyValue('--accent') || '#6ab0ff';
  fctx.shadowColor = fctx.strokeStyle;
  fctx.shadowBlur = 1.5*dpr;

  // 9 celdas
  for (let i=0;i<9;i++){
    if (!neighbors[i].includes(emptyPos)) continue;
    const {x,y,w,h} = layout.cells[i];
    roundRectPath(fctx, x+1, y+1, w-2, h-2, 10*dpr);
    fctx.stroke();
  }

  // muelle (casilla 10)
  if (neighbors[9].includes(emptyPos)){
    const {x,y,w,h} = layout.dock;
    roundRectPath(fctx, x+1, y+1, w-2, h-2, 10*dpr);
    fctx.stroke();
  }
}

  function safeRender(){
    drawingSuspended = true;
    render();
    sizeDockToCell();
    computeLayout();
    requestAnimationFrame(()=>{
      drawingSuspended = false;
      if (mediaType === 'video') drawVideoTiles();
      else drawHighlights(); // üëà para im√°genes tambi√©n
    });
  }

  /* ---------- Render tablero (DOM) ---------- */
  function render(){
    boardEl.innerHTML = '';
    dockEl.querySelectorAll('.cell').forEach(n=>n.remove()); // respetar dockCanvas

    const emptyPos = pos.indexOf(EMPTY);

    for(let i=0;i<9;i++){
      const val = pos[i];
      const cell = document.createElement('div');
      cell.className = 'cell';

      if(val === EMPTY){
        cell.style.background = 'rgba(255,255,255,.03)';
        cell.style.outline = '1px dashed rgba(255,255,255,.12)';
        cell.style.outlineOffset = '-6px';
      } else if(ready && mediaURL && mediaType === 'image'){
        cellBackground(cell, val);
      }
      if(neighbors[i].includes(emptyPos)) cell.classList.add('movable');
      attachSlideHandlers(cell, i);
      boardEl.appendChild(cell);
    }

    const v9 = pos[9];
    const dockCell = document.createElement('div');
    dockCell.className = 'cell';
    if(v9 !== EMPTY){
      if(ready && mediaURL && mediaType === 'image'){
        cellBackground(dockCell, v9);
      } else {
        // v√≠deo: lo pinta dockCanvas; dejamos placeholder transparente
        dockCell.style.background = 'rgba(255,255,255,.00)';
      }
    } else {
      dockCell.style.background = 'rgba(255,255,255,.03)';
      dockCell.style.outline = '1px dashed rgba(255,255,255,.12)';
      dockCell.style.outlineOffset = '-6px';
      // limpiar dockCanvas si queda vac√≠o
      dctx && dctx.clearRect(0,0,dCanvas.width,dCanvas.height);
    }
    attachSlideHandlers(dockCell, 9);
    dockEl.appendChild(dockCell);
  }

  /* ---------- Animaci√≥n de deslizamiento ---------- */
  function animateSlide(fromPos, toPos, onDone){
    const cells = boardEl.querySelectorAll('.cell');
    const originEl = (fromPos===9)? dockEl.querySelector('.cell') : cells[fromPos];
    const targetEl = (toPos===9)? dockEl.querySelector('.cell') : cells[toPos];
    if(!originEl || !targetEl){ onDone(); return; }

    const o = originEl.getBoundingClientRect();
    const t = targetEl.getBoundingClientRect();
    const dx = t.left - o.left;
    const dy = t.top  - o.top;

    originEl.style.transition = 'transform .12s ease-out';
    originEl.style.transform = `translate(${dx}px, ${dy}px)`;
    requestAnimationFrame(()=>{
      setTimeout(()=>{
        originEl.style.transition=''; originEl.style.transform='';
        onDone();
        computeLayout();
        if (mediaType === 'video') drawVideoTiles(); // refrescar dockCanvas
        drawHighlights();
      },130);
    });
  }

  function trySlide(fromPos){
    if(!ready || showing) return;
    const emptyPos = pos.indexOf(EMPTY);
    if(!neighbors[fromPos].includes(emptyPos)) return;
    animateSlide(fromPos, emptyPos, ()=>{
      [pos[fromPos], pos[emptyPos]] = [pos[emptyPos], pos[fromPos]];
      moves++; movesEl.textContent = moves;
      safeRender(); checkWin();
      if(navigator.vibrate) navigator.vibrate(15);
    });
  }

  function attachSlideHandlers(el, posIndex){
    el.addEventListener('click', ()=>trySlide(posIndex));
    let startX=0,startY=0,tracking=false;
    const start = (x,y)=>{ tracking=true; startX=x; startY=y; };
    const move  = (x,y)=>{
      if(!tracking) return;
      const dx=x-startX, dy=y-startY;
      const emptyPos = pos.indexOf(EMPTY);
      if(!neighbors[posIndex].includes(emptyPos)) return;
      if(Math.abs(dx)>12 || Math.abs(dy)>12){ trySlide(posIndex); tracking=false; }
    };
    const end=()=>{ tracking=false; };
    el.addEventListener('mousedown', e=>start(e.clientX,e.clientY));
    window.addEventListener('mousemove', e=>move(e.clientX,e.clientY));
    window.addEventListener('mouseup', end);
    el.addEventListener('touchstart', e=>{ const t=e.changedTouches[0]; start(t.clientX,t.clientY); },{passive:false});
    el.addEventListener('touchmove',  e=>{ const t=e.changedTouches[0]; move(t.clientX,t.clientY); },{passive:false});
    el.addEventListener('touchend', end);
    el.addEventListener('touchcancel', end);
  }

  /* ---------- Win ---------- */
  function isSolved(){ for(let i=0;i<9;i++) if(pos[i]!==i) return false; return pos[9]===EMPTY; }
  function showToast(){ toastEl.classList.add('show'); setTimeout(()=>toastEl.classList.remove('show'), 1600); }
  function checkWin(){ const win = ready && isSolved(); if(win){ showToast(); if(navigator.vibrate) navigator.vibrate([20,60,20]); } }

  /* ---------- Shuffle ---------- */
  function moveEmptyToDock(maxSteps=80){
    let e = pos.indexOf(EMPTY);
    if (e === -1) { pos[9]=EMPTY; return; }
    let last=-1, steps=0;
    while(e!==9 && steps<maxSteps){
      const neigh = neighbors[e] || [];
      if(!neigh.length) break;
      const next = neigh.includes(9) ? 9 : (neigh.find(n=>n!==last) ?? neigh[0]);
      [pos[next], pos[e]] = [pos[e], pos[next]];
      last=e; e=next; steps++;
    }
  }

  function shuffle(times=160){
    if(!ready) return;
    pos = [0,1,2,3,4,5,6,7,8, EMPTY];
    let last = -1;
    for(let k=0;k<times;k++){
      const e = pos.indexOf(EMPTY);
      const neigh = neighbors[e] || [];
      if(!neigh.length) break;
      const cands = neigh.filter(n=>n!==last);
      const pick = cands[Math.floor(Math.random()*cands.length)];
      [pos[pick], pos[e]] = [pos[e], pos[pick]];
      last = e;
    }
    if(pos.indexOf(EMPTY)===-1) pos[9]=EMPTY;
    moveEmptyToDock();
    moves=0; movesEl.textContent=moves;
    safeRender(); checkWin();
  }

  /* ---------- Imagen ---------- */
  async function loadImage(file){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.decoding = 'async';
      img.onload = ()=>{
        const side = Math.min(img.width, img.height);
        const sx = Math.floor((img.width - side)/2);
        const sy = Math.floor((img.height - side)/2);
        const dpr = Math.min(2.5, window.devicePixelRatio||1);
        let base = 900; if (window.devicePixelRatio >= 2) base = 1100;
        const size = Math.min(base * dpr, 1400);
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, sx, sy, side, side, 0, 0, size, size);
        resolve(canvas.toDataURL('image/jpeg', 0.9));
      };
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }

  /* ---------- V√≠deo ---------- */
  function setupMasterVideo(url){
    if (masterVideo) {
      cancelAnimationFrame(rafId);
      masterVideo.pause();
      masterVideo.remove();
    }
    masterVideo = document.createElement('video');
    masterVideo.src = url;
    masterVideo.muted = true; masterVideo.playsInline = true; masterVideo.preload = 'auto';
    masterVideo.loop = true;
    masterVideo.style.display = 'none';
    document.body.appendChild(masterVideo);

   masterVideo.addEventListener('timeupdate', function(e){
  const v = e.target || this;
  if (!v) return;
  if (v.currentTime >= BOOM_END - 0.02) v.currentTime = 0.01;
});


    masterVideo.addEventListener('loadedmetadata', ()=>{
      masterVideo.currentTime = 0.01;
      masterVideo.play().catch(()=>{});

      if ('requestVideoFrameCallback' in masterVideo){
        const step = ()=>{ drawVideoTiles(); masterVideo.requestVideoFrameCallback(step); };
        masterVideo.requestVideoFrameCallback(step);
      } else {
        let last=0;
        const loop = (t)=>{ if (t-last>33) { drawVideoTiles(); last=t; } rafId = requestAnimationFrame(loop); };
        rafId = requestAnimationFrame(loop);
      }
    });
  }

  function drawVideoTiles(){
    if (drawingSuspended) return;
    if (!masterVideo || masterVideo.readyState < 2 || !layout) return;

    const vw = masterVideo.videoWidth, vh = masterVideo.videoHeight;
    if(!vw || !vh) return;

    // recorte cuadrado centrado
    const side = Math.min(vw, vh);
    const sx0 = ((vw - side) / 2) | 0;
    const sy0 = ((vh - side) / 2) | 0;

    // buffer reducido
    srcCanvas.width = SRC_SIZE; srcCanvas.height = SRC_SIZE;
    sctx.drawImage(masterVideo, sx0, sy0, side, side, 0, 0, SRC_SIZE, SRC_SIZE);

    // backbuffer tablero
    backCanvas.width  = vCanvas.width;
    backCanvas.height = vCanvas.height;
    bctx.clearRect(0,0,backCanvas.width,backCanvas.height);

    const ts = SRC_SIZE / 3;

    // 9 celdas (tablero)
    for (let i=0;i<9;i++){
      const val = pos[i];
      if (val === EMPTY) continue;
      const {x,y,w,h} = layout.cells[i];
      const cx = val % 3, cy = (val/3)|0;
      bctx.drawImage(srcCanvas, cx*ts, cy*ts, ts, ts, x, y, w, h);
    }

    // copiar backbuffer al canvas visible del tablero
    vctx.clearRect(0,0,vCanvas.width,vCanvas.height);
    vctx.drawImage(backCanvas, 0, 0);

    // muelle (casilla 10): se pinta en su canvas dedicado
    drawHighlights(); // üëà refresca el borde azul
    dctx.clearRect(0,0,dCanvas.width,dCanvas.height);
    const v9 = pos[9];
    if (v9 !== EMPTY){
      const cx = v9 % 3, cy = (v9/3)|0;
      dctx.drawImage(srcCanvas, cx*ts, cy*ts, ts, ts, 0, 0, dCanvas.width, dCanvas.height);
    }
  }

  /* ---------- Carga archivo ---------- */
 fileInput.addEventListener('change', async (e)=>{
  const file = e.target.files?.[0]; 
  if(!file) return;

  try{
    // 1) Si ven√≠amos de un v√≠deo, desmonta todo
    teardownVideo();

    // 2) Libera el ObjectURL anterior si lo hab√≠a
    if (mediaURL) {
      try { URL.revokeObjectURL(mediaURL); } catch(e){}
    }

    // 3) Carga nueva media
    if (file.type.startsWith('video/')){
      mediaType = 'video';
      mediaURL = URL.createObjectURL(file);
      setupMasterVideo(mediaURL);
    } else {
      mediaType = 'image';
      mediaURL = await loadImage(file);
      // Asegura que no queda ning√∫n frame de v√≠deo visible
      vctx.clearRect(0,0,vCanvas.width, vCanvas.height);
      dctx.clearRect(0,0,dCanvas.width, dCanvas.height);
    }

    // 4) Reset de tablero
    ready = true;
    shuffleBtn.disabled = false;
    showBtn.disabled    = false;
    pos = [0,1,2,3,4,5,6,7,8, EMPTY];
    moves = 0; 
    movesEl.textContent = moves;
    safeRender(); 
    shuffle(160);
    if (mediaType === 'video') drawVideoTiles();

  }catch(err){ 
    console.error(err); 
  }
});


  /* ---------- Controles ---------- */
  document.getElementById('shuffleBtn').addEventListener('click', ()=>{
    shuffle(140);
    if(mediaType==='video') drawVideoTiles();
  });

  function showFullImage(){
    if(!ready || showing) return;
    savedPos = pos.slice(); showing = true;
    pos = [0,1,2,3,4,5,6,7,8, EMPTY];
    safeRender(); if(mediaType==='video') drawVideoTiles();
  }
  function hideFullImage(){
    if(!showing) return;
    showing = false; pos = savedPos.slice(); safeRender(); if(mediaType==='video') drawVideoTiles();
  }
  showBtn.addEventListener('mousedown', showFullImage);
  showBtn.addEventListener('mouseup', hideFullImage);
  showBtn.addEventListener('mouseleave', hideFullImage);
  showBtn.addEventListener('touchstart', e=>{ e.preventDefault(); showFullImage(); }, {passive:false});
  showBtn.addEventListener('touchend', hideFullImage);
  showBtn.addEventListener('touchcancel', hideFullImage);

  /* ---------- Inicial ---------- */
  safeRender();
  window.addEventListener('resize', ()=>{
    sizeDockToCell();
    computeLayout();
    if(mediaType==='video') drawVideoTiles();
  });
  // üîß Mata el v√≠deo y limpia todo lo relacionado
function teardownVideo(){
  try { cancelAnimationFrame(rafId); } catch(e){}
  if (masterVideo){
    try { masterVideo.pause(); } catch(e){}
    // quita handlers para evitar llamadas posteriores
    masterVideo.src = '';
    masterVideo.remove();
    masterVideo = null;
  }
  // limpia los canvas donde se pintaba el v√≠deo
  vctx.clearRect(0,0,vCanvas.width, vCanvas.height);
  dctx.clearRect(0,0,dCanvas.width, dCanvas.height);
}

  // ‚úÖ Nueva mejora: pausa y reanuda el video cuando se oculta o vuelve la pesta√±a
document.addEventListener('visibilitychange', ()=>{
  if (!masterVideo) return;
  if (document.hidden) masterVideo.pause();
  else masterVideo.play().catch(()=>{});
});
</script>
</body>
</html>
