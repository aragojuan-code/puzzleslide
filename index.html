<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Puzzle deslizante 3×3 + muelle</title>
<style>
  :root{--bg:#0f141b;--panel:#121a23;--muted:#9fb3c9;--tile:#101722;--accent:#6ab0ff;--grid:rgba(230,238,247,.18)}
  html,body{height:100%;margin:0;background:var(--bg);color:#e6eef7;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  .wrap{max-width:680px;margin:0 auto;padding:16px}
  header{display:flex;align-items:center;justify-content:space-between;gap:8px}
  h1{font-size:20px;margin:0}
  .controls{display:flex;gap:8px;flex-wrap:wrap}
  button,label.btn{background:var(--panel);color:#e6eef7;border:1px solid rgba(255,255,255,.12);padding:10px 12px;border-radius:10px;cursor:pointer}
  button[disabled],label.btn.disabled{opacity:.5;cursor:not-allowed}
  button:hover,label.btn:hover{border-color:rgba(255,255,255,.25)}
  input[type=file]{display:none}

  /* Zona del tablero + muelle (dock) */
  .stage{
    position:relative;
    width:100%; max-width:460px; margin:16px auto 10px;
  }
  .board-wrap{
    position:relative;
    width:100%;
    height:420px; /* fallback */
    aspect-ratio:1/1;
  }
  .board{
    position:absolute; inset:0;
    display:grid; grid-template-columns:repeat(3,1fr); grid-template-rows:repeat(3,1fr);
    gap:8px; padding:8px;
    background:linear-gradient(180deg,#0b1118,#0e1722);
    border:1px solid rgba(255,255,255,.06); border-radius:16px;
  }
  .cell{
    border-radius:12px; border:1px solid rgba(255,255,255,.08);
    background:var(--tile); background-repeat:no-repeat; background-size:300% 300%;
    transition:transform .08s ease-out, box-shadow .12s ease, background-color .12s ease;
    display:flex; align-items:center; justify-content:center;
  }
  .cell.movable{ box-shadow:0 0 0 2px var(--accent) inset }
  .cell.flash{ transform:scale(1.04) }

  /* cuadrícula suave (siempre visible) */
  .grid-overlay{ position:absolute; inset:8px; pointer-events:none }
  .gline{ position:absolute; background:var(--grid); border-radius:2px; filter:blur(.2px) }
  .gv1{ top:0; bottom:0; left:calc(33.333% - 1px); width:2px }
  .gv2{ top:0; bottom:0; left:calc(66.666% - 1px); width:2px }
  .gh1{ left:0; right:0; top:calc(33.333% - 1px); height:2px }
  .gh2{ left:0; right:0; top:calc(66.666% - 1px); height:2px }

  /* Muelle (casilla #10) bajo la esquina inferior derecha */
  .dock-wrap{
    position:relative; height:120px; margin-top:12px;
  }
  .dock{
    position:absolute; right:0; /* pegado al borde derecho del board */
    width:120px; height:120px;
    border-radius:12px; border:1px solid rgba(255,255,255,.08);
    background:linear-gradient(180deg,#0b1118,#0e1722);
    display:flex; align-items:center; justify-content:center;
  }
  .dock .cell{ width:100%; height:100%; border:none; border-radius:12px }

  .info{display:flex;gap:8px;flex-wrap:wrap}
  .pill{padding:6px 10px;border:1px solid rgba(255,255,255,.12);border-radius:999px;background:rgba(255,255,255,.05);font-size:14px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Puzzle 3×3 con muelle</h1>
    <div class="controls">
      <label for="fileInput" class="btn" id="loadBtn">Cargar foto</label>
      <button id="shuffleBtn" disabled>Mezclar</button>
      <button id="resetBtn" disabled>Reiniciar</button>
      <input id="fileInput" type="file" accept="image/*">
    </div>
  </header>

  <div class="stage">
    <div class="board-wrap">
      <div id="board" class="board"></div>
      <!-- cuadrícula -->
      <div class="grid-overlay">
        <div class="gline gv1"></div><div class="gline gv2"></div>
        <div class="gline gh1"></div><div class="gline gh2"></div>
      </div>
    </div>
    <!-- muelle debajo a la derecha -->
    <div class="dock-wrap">
      <div id="dock" class="dock" title="Muelle (hueco externo)"></div>
    </div>
  </div>

  <div class="info">
    <div class="pill"><strong>Movs:</strong> <span id="moves">0</span></div>
    <div class="pill"><strong>Estado:</strong> <span id="status">Carga una foto</span></div>
  </div>
</div>

<script>
  // Representamos 10 posiciones: 0..8 (grid 3×3) y 9 (muelle)
  // Contenido: 0..8 = trozos de la imagen; -1 = hueco vacío
  const EMPTY = -1;
  let pos = [0,1,2,3,4,5,6,7,8, EMPTY]; // resuelto + muelle vacío
  let moves = 0;
  let imgURL = null;
  let imageReady = false;

  const boardEl = document.getElementById('board');
  const dockEl  = document.getElementById('dock');
  const movesEl = document.getElementById('moves');
  const statusEl= document.getElementById('status');
  const fileInput = document.getElementById('fileInput');
  const shuffleBtn= document.getElementById('shuffleBtn');
  const resetBtn  = document.getElementById('resetBtn');

  // Adyacencias (grid 0..8) + conexión 8 <-> 9 (muelle)
  const neighbors = {
    0:[1,3],
    1:[0,2,4],
    2:[1,5],
    3:[0,4,6],
    4:[1,3,5,7],
    5:[2,4,8],
    6:[3,7],
    7:[4,6,8],
    8:[5,7,9], // esquina abajo-dcha conectada al muelle
    9:[8]      // muelle conecta solo con 8
  };

  function render(){
    // limpia
    boardEl.innerHTML = '';
    dockEl.innerHTML = '';

    // localiza hueco
    const emptyPos = pos.indexOf(EMPTY);

    // pinta 0..8 (grid)
    for(let i=0;i<9;i++){
      const v = pos[i]; // contenido en la posición i
      const cell = document.createElement('div');
      cell.className = 'cell';
      // pintable (si no es hueco)
      if(v !== EMPTY && imageReady && imgURL){
        const cx = v % 3, cy = Math.floor(v/3);
        const px = cx===0? '0%' : (cx===1? '50%' : '100%');
        const py = cy===0? '0%' : (cy===1? '50%' : '100%');
        cell.style.backgroundImage = `url(${imgURL})`;
        cell.style.backgroundPosition = `${px} ${py}`;
      }
      // movible si adyacente al hueco
      if(neighbors[i].includes(emptyPos)) cell.classList.add('movable');
      cell.addEventListener('click', ()=> trySlide(i));
      boardEl.appendChild(cell);
    }

    // pinta muelle (pos 9)
    const v9 = pos[9];
    const dockCell = document.createElement('div');
    dockCell.className = 'cell';
    if(v9 !== EMPTY && imageReady && imgURL){
      const cx = v9 % 3, cy = Math.floor(v9/3);
      const px = cx===0? '0%' : (cx===1? '50%' : '100%');
      const py = cy===0? '0%' : (cy===1? '50%' : '100%');
      dockCell.style.backgroundImage = `url(${imgURL})`;
      dockCell.style.backgroundPosition = `${px} ${py}`;
    } else {
      // muelle vacío con una leve indicación
      dockCell.style.background = 'rgba(255,255,255,.03)';
      dockCell.style.outline = '1px dashed rgba(255,255,255,.12)';
      dockCell.style.outlineOffset = '-6px';
    }
    if(neighbors[9].includes(emptyPos)) dockCell.classList.add('movable');
    dockCell.addEventListener('click', ()=> trySlide(9));
    dockEl.appendChild(dockCell);
  }

  function trySlide(fromPos){
    if(!imageReady) return;
    const emptyPos = pos.indexOf(EMPTY);
    if(!neighbors[fromPos].includes(emptyPos)) return; // no adyacente -> no se mueve
    // anima la celda origen (si pertenece al grid)
    const cells = (fromPos<9) ? boardEl.querySelectorAll('.cell') : dockEl.querySelectorAll('.cell');
    const idx   = (fromPos<9) ? fromPos : 0;
    cells[idx].classList.add('flash');
    setTimeout(()=>cells[idx].classList.remove('flash'), 120);
    // swap
    [pos[fromPos], pos[emptyPos]] = [pos[emptyPos], pos[fromPos]];
    moves++; movesEl.textContent = moves;
    render(); checkWin();
  }

  function isSolved(){
    for(let i=0;i<9;i++) if(pos[i]!==i) return false;
    return pos[9]===EMPTY; // muelle vacío
  }

  function checkWin(){
    const win = imageReady && isSolved();
    statusEl.textContent = win ? '¡Resuelto! ✨' : (imageReady ? 'Jugando…' : 'Carga una foto');
    if(win && navigator.vibrate) navigator.vibrate(60);
  }

  // Mezcla con movimientos legales (siempre resoluble)
  function shuffle(times=120){
    if(!imageReady) return;
    pos = [0,1,2,3,4,5,6,7,8, EMPTY];
    let last = -1;
    for(let k=0;k<times;k++){
      const e = pos.indexOf(EMPTY);
      const cands = neighbors[e].filter(n => n!==last);
      const pick = cands[Math.floor(Math.random()*cands.length)];
      [pos[pick], pos[e]] = [pos[e], pos[pick]];
      last = e;
    }
    moves=0; movesEl.textContent=moves;
    render(); checkWin();
  }

  // Recorta imagen al centro (cuadrada)
  async function cropToSquare(file){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = ()=>{
        const side = Math.min(img.width, img.height);
        const sx = Math.floor((img.width - side)/2);
        const sy = Math.floor((img.height - side)/2);
        const dpr = Math.min(2, window.devicePixelRatio||1);
        const size = 900*dpr;
        const canvas = document.createElement('canvas');
        canvas.width = size; canvas.height = size;
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingQuality = 'high';
        ctx.drawImage(img, sx, sy, side, side, 0, 0, size, size);
        resolve(canvas.toDataURL('image/jpeg', 0.92));
      };
      img.onerror = reject;
      img.src = URL.createObjectURL(file);
    });
  }

  // Cargar foto
  fileInput.addEventListener('change', async (e)=>{
    const file = e.target.files?.[0]; if(!file) return;
    statusEl.textContent = 'Procesando foto…';
    try{
      imgURL = await cropToSquare(file);
      imageReady = true;
      shuffleBtn.disabled = false;
      resetBtn.disabled = false;
      pos = [0,1,2,3,4,5,6,7,8, EMPTY];
      moves = 0; movesEl.textContent = moves;
      render(); checkWin();
      shuffle(160); // baraja de inicio
    }catch(err){
      console.error(err);
      statusEl.textContent = 'Error al cargar la imagen';
    }
  });

  // Controles
  document.getElementById('shuffleBtn').addEventListener('click', ()=>shuffle(140));
  document.getElementById('resetBtn').addEventListener('click', ()=>{
    if(!imageReady) return;
    pos = [0,1,2,3,4,5,6,7,8, EMPTY]; moves=0; movesEl.textContent=moves; render(); checkWin();
  });

  // Render inicial (cuadrícula vacía)
  render();
</script>
</body>
</html>
